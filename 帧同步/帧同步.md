### 帧同步

帧同步游戏中，由于需要“每一帧”都要广播数据，所以广播的频率非常高，这就要求每次广播的数据要足够的小。最好每一个网络帧，能在一个MTU以下，这样才能有效降低底层网络的延迟。同样的理由，我们为了提高实时性，一般也倾向于使用UDP而不是TCP协议，这样底层的处理会更高效。但是，这样也会带来了丢包、乱序的可能性。因此我们常常会以冗余的方式——比如每个帧数据包，实际上是包含了过去2帧的数据，也就是每次发3帧的数据，来对抗丢包。也就是说三个包里面只要有一个包没丢，就不影响游戏。另外我们还会在RelayServer上保存大量的客户端上传的数据，如果客户端发现丢了包（如果乱序了也认为是丢包），那么就发起一次“下载”请求，从服务器上重新下载丢失了的帧数据包（这个可能会使用TCP）。这一切，都依赖于每个帧数据要足够的小。

一般要求，每次客户端发送的数据，应该小于128字节。你可以大概计算一下，如果我们的游戏有4个玩家，我们的冗余是3帧，那么一个下行的网络帧数据包大小会到128x4x3=1536字节，而每秒我们发15个网络帧，那么占用的带宽会到1536x15=23,040字节/秒，加上一些底层协议包头也就是24kB/s，这个速度看起来已经要求手机是3G网络才能支持了（实测中GPRS一般很难稳定到这个速度）。

降低广播数据量的做法就是自己编写序列化函数：一般现代编程语言，特别是面向对象的语言，都带有把对象序列化和反序列化的功能

### 关于流畅度优化

1. 一致性：做帧同步的目标是各个客户端能看到一致的显示。但是游戏内容很多，有一部分内容是可以容忍不一致的。
2. 实时性。一般来说，我们都希望游戏中的角色控制是灵敏的，实时的。我们的游戏角色往往在会玩家输入操作后的几十分之一秒内，就开始显示变化。在帧同步游戏中，我们可以让玩家一输入完操作，就立刻发包，然后尽快在下一个收到的网络帧中收到这个操作，从而尽快的完成显示。然而，网络并不是那么稳定，我们常常会发现一会快一会慢，这样玩家的操作体验就非常奇怪，无法预测输入动作后，角色会在什么时候起反应。这对于一些讲求操作实时性的游戏是很麻烦的。要解决这个问题，我们一般可以学习传输语音业务的做法，就是接收网络数据时，不立刻处理，而是给所有的操作增加一个固定的延迟，后在延迟的时间内，搜集多几个网络包，然后按固定的时间去播放（运算）。这样做了一个网络帧的缓冲区，用来平滑布局云网速，改成匀速运算。
3. 公平性。公平性可以使用锁步帧实现。